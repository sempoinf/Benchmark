#include "arr_handler.h"

/* --------------- quick sort -------------------- */


#include <stdio.h>

void swap(int i, int j, int *arr) { // Функция для i на j, а j на i (из массива arr)
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
void qs(int, int, int*);   // сигнатура ( это для того, чтобы можно было написать функцию после main() )

void main() {
    int N = 19;
    int array[19] = { 14, 19, 27, 38, 54, 7897, 3245, 98765, 567, 32412, 0, 101, 128, 276, 15, 7, 23, 65, 74 }; // пример

    qs(0, (N-1), array);                // Сортировка массива
    for (int i = 0; i < N; i++) {       // Печать отсортированного массива
        printf("%d\n", (array[i]));
    }
}

//  функция быстрой сортировки
void qs(int low, int high, int* array) {        // Приниает на вход индекс первого элемента, последнего, а также массив, который нужно отсортировать
    int mid = (int)(low + ((high - low) / 2));  // mid - это центр или опорный элемент
    int l, r;           // l - индекс левого элемента, r - правого

    l = low;
    r = high;
    do {
        while (array[l] < array[mid])       // Ищем элемент слева от опрного, который > опорного
            l++;
        if (l != mid) {         // Если нашли (не дошли до опроного)
            while (array[r] > array[mid])   // Ищем элемент справа от опрного, который < опорного
                r--;

            if (r > mid) {                                            // Стандартная ситуация (есть эл. слева от опорного, который > опорного и справа от опорного, котрый < опорного)
                swap(l, r, array);                                    // Просто меняем их местами
            }
            else {                                                   // r = mid, т.е. слева нашли, справа не нашли
                swap((mid - 1), l, array);                           // меняем левый от mid с эл. > mid
                swap(mid, (mid - 1), array);                         // после меняем эл. > mid (он слева от mid) с mid
                r = mid -= 1;                                        // mid подвинулся, r был равен mid => он тоже должен подвинуться
            }
        }
        else {                                      // l = mid
            while (array[r] > array[mid])
                r--;
            if (r != l) {                                           // Слева не нашли, справа нашли
                swap((mid + 1), r, array);                          // Тоже, что и выше, но в обратную сторону
                swap(mid, (mid + 1), array);
                l = mid += 1;
            }
        }
    } while (l < r);                                              // Если l и r не встретились в mid (l != r) то значит мы не все элементы проверили и нужна еще итерация
  /*  for (int i = 0; i < 19; i++) {
        printf("%d ", (array[i]));                                // Печатает массив, отсортированный по опорному эллементу
    }
    printf("\n");
    */
    if ((high - low) > 1) {                 // high - low = 1 означает, что наш массив состоит из 2 эл. (т.к. array[0] - 1ый эл., [1] - 2ой
 // для массива из 2 эл. все что написано выше поставит меньший эл. слева, а больший справа т.е. этот массив будет отсортирован в порядке возрастнания
        qs(low, mid, array);        // вызываем функцию заново, но говорим ей сортировать левую (от mid) часть
        qs(mid, high, array);       // правую (от mid) часть
    }                               // фунуция будет вызываться рекурсивно, в конце получим отсортированный массив
}


/* ----------------------------------------------------------------- */


/*------------------------- Counting sort ------------------------- */


#define SIZE 15 // мы предполагаем, что у нас есть 15 элементов в массиве

void counting_sort(int*, int*, int, int, int); //прототип функции, которая выполняет сортировку.

void main()
{
  int given_array[SIZE]={100,82,87,91,87,97,91,90,82,80,97,100,99,80,88}; //пример.

  int max=100; //наибольшее число в массиве, в данном случае 100.
  int min=80;  //наименьшее число в массиве, в данном случае 80.

  int sorted_array[SIZE];
  printf("\n");

 counting_sort(given_array, sorted_array, SIZE, max, min);
}

void counting_sort(int given_array[], int sorted_array[], int size, int max, int min)
{
  int length=max-min;
  int counting_array[length+1];   /*массив с количеством вхождений каждого элемента исходного         массива. размер этого массива - это разница между наибольшим и наименьшим целыми числами исходного массива + 1.*/
  int k=0;


  for(int i=0;i<=length;i++)
  {
     counting_array[i]=0; //инициализируем ячейки массива нулями
  }

//подсчитываем количество вхождений каждого элемента исходного массива, складываем эти числа в массив.
  for(int j=0; j<size; j++)
   {
     counting_array[given_array[j]-min]+=1;
   }

//строим отсортированный массив
   while(k<size)
   {
     for(int i=0; i<=length; i++)
       {
          for(int l=0; l<counting_array[i]; l++)
            { sorted_array[k]=i+min;
              k++;
            }
       }
   }

   //отображаем отсортированный массив
   for(int i=0; i<size; i++)
    printf("%d ", sorted_array[i]);
    printf("\n");
}


/* ----------------------------------------------------------------- */
